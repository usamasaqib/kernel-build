import os
import glob
import json
import netifaces
from invoke import task
from invoke.exceptions import Exit
from invoke.context import Context as InvokeContext
from pathlib import Path

from typing import Optional
from tasks.kernel import (
    KernelVersion,
    KernelManifest,
    KernelBuildPaths,
    get_kernel_pkg_dir,
)
from tasks.arch import Arch
from tasks.tool import info

DEBIAN_SOURCE_LISTS = """
deb http://deb.debian.org/debian bullseye main
deb-src http://deb.debian.org/debian bullseye main

deb http://deb.debian.org/debian-security/ bullseye-security main
deb-src http://deb.debian.org/debian-security/ bullseye-security main

deb http://deb.debian.org/debian bullseye-updates main
deb-src http://deb.debian.org/debian bullseye-updates main
"""

DEFAULT_IMG_SIZE = "20G"
DEFAULT_DEBIAN = "bullseye"

IP_ADDR = "169.254.%s.1"
GUEST_ADDR = "169.254.%s.2"

# PACKAEGS TO ADD
# python
PREINSTALL_PKGS = (
    "curl,dpkg,lsb-release,net-tools,openssh-server,rsync,socat,vim,wget,xz-utils"
)


class RootfsBuildPaths:
    images_dir = Path("./images")
    chroot = images_dir / "chroot"


def add_repos(ctx: InvokeContext) -> None:
    sources_list = RootfsBuildPaths.chroot / "etc/apt/sources.list"
    ctx.run(f"echo '{DEBIAN_SOURCE_LISTS}' | sudo tee {sources_list}")


# These are the debian packages created during kernel build
# These include the headers the debug build of the kernel, etc.
# Check the ./kernels/sources/kernel-[version] directory for all of them
def install_deb_packages(ctx: InvokeContext, kernel_version: KernelVersion) -> None:
    pkg_dir = get_kernel_pkg_dir(kernel_version)
    if not pkg_dir.exists():
        raise Exit(f"package dir for version {kernel_version} does not exist")

    deb_files = glob.glob(f"{pkg_dir}/linux-image*.deb")
    scratch = RootfsBuildPaths.images_dir / "scratch"

    # We do not use dpkg-deb -x directly because the root filesystem has
    # some symlinks which do not correspond to the layout generated by the
    # kernel compilation.
    # Using tar -h allows us to respect the layout of the root filesystem
    for pkg in deb_files:
        ctx.run(f"mkdir {scratch}")
        ctx.run(f"cp {pkg} {scratch}")
        pkg_name = os.path.basename(pkg)
        ctx.run(f"dpkg-deb --fsys-tarfile {scratch}/{pkg_name} > {scratch}/pkg.tar")
        ctx.run(f"sudo tar -h -xvf {scratch}/pkg.tar -C {RootfsBuildPaths.chroot}")
        ctx.run(f"rm -rf {scratch}")


def all_guest_gateways() -> list[str]:
    all_kernels = glob.glob(f"{KernelBuildPaths.kernel_sources_dir}/kernel-*")
    tap_ips = list()
    for k in all_kernels:
        with open(os.path.join(k, "kernel.manifest"), "r") as f:
            manifest = json.load(f)
            if "gateway_ip" in manifest:
                tap_ips.append(manifest["gateway_ip"])

    return tap_ips


AF_INET = 2


def interface_ips() -> list[str]:
    interfaces = netifaces.interfaces()
    ips = list()
    for netif in interfaces:
        info = netifaces.ifaddresses(netif)
        if AF_INET not in info:
            continue

        ip = info[AF_INET][0]["addr"]
        ips.append(ip)

    return ips


def find_tap_ip() -> tuple[str, int]:
    taken_ips = all_guest_gateways()
    up_interfaces = interface_ips()

    for i in range(0, 256):
        tap_ip = IP_ADDR % i
        if tap_ip in taken_ips or tap_ip in up_interfaces:
            continue

        return tap_ip, i

    raise Exit(f"no IP available in range {IP_ADDR % 0}/24")


def run_script(ctx: InvokeContext, script: str) -> None:
    name = "script.tmp.sh"
    with open(name, 'w') as f:
        f.write(script)

    info(f"[+] Executing script:\n{script}")
    ctx.run("bash ./script.tmp.sh")
    ctx.run("rm ./script.tmp.sh")


def setup_guest_network(
    ctx: InvokeContext, version: KernelVersion, kuuid: str
) -> tuple[str, str]:
    kernel_dir = get_kernel_pkg_dir(version)
    tap_ip, subnet = find_tap_ip()
    guest_ip = GUEST_ADDR % subnet

    setup_guest_network = f"""
#!/bin/bash
echo "auto eth0\niface eth0 inet static\n\taddress {guest_ip}/30\n\tgateway {tap_ip}\n" | sudo tee {RootfsBuildPaths.chroot}/etc/network/interfaces
rm {kernel_dir}/vm-{kuuid}.id_rsa*
ssh-keygen -f {kernel_dir}/vm-{kuuid}.id_rsa -t rsa -N ''
sudo mkdir -p {RootfsBuildPaths.chroot}/root/.ssh/
cat {kernel_dir}/vm-{kuuid}.id_rsa.pub | sudo tee -a {RootfsBuildPaths.chroot}/root/.ssh/authorized_keys
echo 'ssh -o StrictHostKeyChecking=false -o ServerAliveInterval=100000 root@{guest_ip} -i {kernel_dir.absolute()}/vm-{kuuid}.id_rsa' > {kernel_dir}/ssh_connect
chmod +x {kernel_dir}/ssh_connect
echo 'ssh -o StrictHostKeyChecking=false root@{guest_ip} -i {kernel_dir.absolute()}/vm-{kuuid}.id_rsa \"reboot\"' > {kernel_dir}/ssh_shutdown
chmod +x {kernel_dir}/ssh_shutdown
"""
    run_script(ctx, setup_guest_network)

    return tap_ip, guest_ip


def _setup_dev_env(
    ctx: InvokeContext,
    kernel_version: KernelVersion,
    manifest: KernelManifest,
    init: bool = True,
) -> KernelManifest:
    if not kernel_version:
        raise Exit("no kernel version provided")

    if init:
        add_repos(ctx)
        tap, guest = setup_guest_network(ctx, kernel_version, manifest["kid"])
        manifest["gateway_ip"] = tap
        manifest["guest_ip"] = guest

    install_deb_packages(ctx, kernel_version)

    return manifest


def _convert_to_qemu(ctx: InvokeContext, release_img: Path, qcow2_img: Path) -> None:
    ctx.run(f"sudo qemu-img convert -f raw -O qcow2 {release_img} {qcow2_img}")
    ctx.run(f"sudo rm {release_img}")
    ctx.run(f"sudo chown 1000:1000 {qcow2_img}")
    info(f"[+] QCOW2 {qcow2_img} written @ {qcow2_img}")


@task  # type: ignore
def setup_dev_env(
    ctx: InvokeContext,
    kernel_version: str,
    init: bool = False,
    release: str = DEFAULT_DEBIAN,
):
    kversion = KernelVersion.from_str(ctx, kernel_version)
    kernel_dir = get_kernel_pkg_dir(kversion)
    kernel_manifest = kernel_dir / "kernel.manifest"
    with open(kernel_manifest, "r") as f:
        manifest = json.load(f)

    rootfs = kernel_dir / "rootfs.qcow2"
    release_img = RootfsBuildPaths.images_dir / f"{release}.img"
    if not init and rootfs.exists():
        ctx.run(f"mv {rootfs} {RootfsBuildPaths.images_dir}/rootfs.qcow2")
        ctx.run(
            f"qemu-img convert {RootfsBuildPaths.images_dir}/rootfs.qcow2 {RootfsBuildPaths.images_dir}/rootfs.raw"
        )
        release_img = RootfsBuildPaths.images_dir / "rootfs.raw"
        ctx.run(f"rm {RootfsBuildPaths.images_dir}/rootfs.qcow2")

    RootfsBuildPaths.chroot.mkdir(exist_ok=True)
    ctx.run(f"sudo chmod 0755 {RootfsBuildPaths.chroot}")
    ctx.run(f"sudo mount -o exec,loop {release_img} {RootfsBuildPaths.chroot}")

    manifest = _setup_dev_env(ctx, kversion, manifest, init=init)
    if not init:
        with open(kernel_manifest, "w") as f:
            json.dump(manifest, f)

    ctx.run(f"sudo umount {RootfsBuildPaths.chroot}")
    ctx.run(f"rm -rf {RootfsBuildPaths.chroot}")
    _convert_to_qemu(
        ctx,
        release_img,
        kernel_dir / "rootfs.qcow2",
    )


@task  # type: ignore
def build(
    ctx: InvokeContext,
    kernel_version: str,
    arch: Optional[str] = None,
    lean: bool = False,
    img_size: str = DEFAULT_IMG_SIZE,
    extra_pkgs: str = "",
    release: str = DEFAULT_DEBIAN,
    qcow2: bool = False,
) -> None:
    rootfs_build(
        ctx,
        KernelVersion.from_str(ctx, kernel_version),
        platform_arch=arch,
        lean=lean,
        img_size=img_size,
        extra_pkgs=extra_pkgs,
        release=release,
        qcow2=qcow2,
    )


def rootfs_build(
    ctx: InvokeContext,
    kernel_version: KernelVersion,
    platform_arch: Optional[str] = None,
    lean: bool = False,
    img_size: str = DEFAULT_IMG_SIZE,
    extra_pkgs: str = "",
    release: str = DEFAULT_DEBIAN,
    qcow2: bool = False,
) -> None:
    if platform_arch is None:
        arch = Arch.local()
    else:
        arch = Arch.from_str(arch)

    release_img = RootfsBuildPaths.images_dir / f"{release}.img"
    RootfsBuildPaths.images_dir.mkdir(exist_ok=True)
    RootfsBuildPaths.chroot.mkdir(exist_ok=True)

    # build environment with debootstrap
    debootparams = f"--arch={arch.debarch} --components=main,contrib,non-free "
    if PREINSTALL_PKGS != "":
        extra_pkgs += f",{PREINSTALL_PKGS}"

    if extra_pkgs != "":
        debootparams += f"--include={extra_pkgs} "

    # build cache archive for packages for faster subsequent builds
    cache_dir = RootfsBuildPaths.images_dir.absolute() / "cache.tar.gz"
    debootstrap_cache_cmd = "true"
    if not os.path.exists(cache_dir):
        cacheparams = (
            debootparams + f"--make-tarball={cache_dir} {release} /tmp/nonexistent"
        )
        if os.path.exists("/tmp/nonexistent"):
            ctx.run("sudo rm -r /tmp/nonexistent")
        debootstrap_cache_cmd = f"sudo debootstrap {cacheparams}"

    debootparams += f"--unpack-tarball={cache_dir} {release} {RootfsBuildPaths.chroot}"
    debootstrap_cmd = f"sudo debootstrap {debootparams}"

    provision_script = f"""
#!/bin/bash
dd if=/dev/zero of={release_img} bs=1 count=0 seek={img_size}
mkfs.ext2 -F {release_img}
sudo chmod 0755 {RootfsBuildPaths.chroot}
sudo mount -o exec,loop {release_img} {RootfsBuildPaths.chroot}
{debootstrap_cache_cmd} && {debootstrap_cmd}
sudo sed -i '/^root/ {{ s/:x:/::/ }}' {RootfsBuildPaths.chroot}/etc/passwd
echo 'T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100' | sudo tee -a {RootfsBuildPaths.chroot}/etc/inittab
'/dev/root / ext4 defaults 0 0' | sudo tee -a {RootfsBuildPaths.chroot}/etc/fstab
echo 'debugfs /sys/kernel/debug debugfs defaults 0 0' | sudo tee -a {RootfsBuildPaths.chroot}/etc/fstab
echo 'mount -t tracefs nodev /sys/kernel/tracing' | sudo tee -a {RootfsBuildPaths.chroot}/etc/fstab
echo 'binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0' | sudo tee -a {RootfsBuildPaths.chroot}/etc/fstab
echo -en "127.0.0.1\tlocalhost\n" | sudo tee {RootfsBuildPaths.chroot}/etc/hosts
echo "nameserver 8.8.8.8" | sudo tee -a {RootfsBuildPaths.chroot}/etc/resolv.conf
echo "myvm" | sudo tee {RootfsBuildPaths.chroot}/etc/hostname
echo -en "127.0.1.1\tmyvm\n" | sudo tee -a {RootfsBuildPaths.chroot}/etc/hosts
"""

    run_script(ctx, provision_script)

    kernel_dir = get_kernel_pkg_dir(kernel_version)
    kernel_manifest = kernel_dir / "kernel.manifest"
    if not lean:
        with open(kernel_manifest, "r") as f:
            manifest = json.load(f)

        manifest = _setup_dev_env(ctx, kernel_version, manifest)

        info(
            f"[+] generate kernel manifest for {kernel_version}:\n{json.dumps(manifest, indent=4)}"
        )
        with open(kernel_manifest, "w") as f:
            json.dump(manifest, f)

    ctx.run(f"sudo umount {RootfsBuildPaths.chroot}")
    ctx.run(f"rm -rf {RootfsBuildPaths.chroot}")

    info("[+] Rootfs build complete. Creating qcow2 file")
    _convert_to_qemu(ctx, release_img, kernel_dir / "rootfs.qcow2")
